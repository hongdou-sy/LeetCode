[toc]

# 31. 下一个排列

## 题目

​	实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

​	必须 原地 修改，只允许使用额外常数空间。

<img src="C:\Users\hongdou\AppData\Roaming\Typora\typora-user-images\image-20220113105956911.png" alt="image-20220113105956911" style="zoom:80%;" />

## 思路及解法

​	注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：

1. 我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。
2. 同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。

   因此，我们的关键首先要找到「较小数」和「较大数」。

   以排列 [4,5,2,6,3,1][4,5,2,6,3,1] 为例：

+ 我们能找到的符合条件的一对「较小数」与「较大数」的组合为 22 与 33，满足「较小数」尽量靠右，而「较大数」尽可能小。
+ 当我们完成交换后排列变为 [4,5,3,6,2,1][4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6][4,5,3,1,2,6]。

  具体地，我们这样描述该算法，对于长度为 *n* 的排列 *a*：

1. 首先从后向前查找第一个顺序对 $(i,i+1)$，满足$ a[i] < a[i+1]$。这样「较小数」即为 $a[i]$。此时$[i+1,n)$必然是下降序列。

2. 如果找到了顺序对，那么在区间 $[i+1,n)$ 中从后向前查找第一个元素 $j$ 满足 $a[i] < a[j]$。这样「较大数」即为$a[j]$。
3. 交换 $a[i]$ 与 $a[j]$，此时可以证明区间 $[i+1,n)$ 必为降序。我们可以直接使用双指针反转区间 $[i+1,n)$ 使其变为升序（可以直接使用reverse函数，而无需对该区间进行排序。

4. 如果在步骤1中从右往左一直找到$i==0$的位置都没有满足$a[i]<a[i+1]$ ，说明整个序列已经是最大序列了（及降序序列），这是直接用reverse对其进行逆序即可。

## 代码

```C++
class Solution {
public:
    void nextPermutation(vector<int>& nums) { //知识点1.形参实参的传递(为什么这里要用引用'&'?)
        if(nums.size()==0) return; //容器中无元素 
	
	//①先找到左边的较小数和右边的较大数
	//从右往左进行查找，直到nums[i]<nums[i+1]，则nums[i]就是较小数(且[i+1,n)必然是降序) 
	int n=nums.size(); //获取容器的元素个数n
	int i=n-2;
	int j=n-1;
	for(;i>=0;i--) //从右往左遍历容器 
	{
		if(i==0&&nums[i]>nums[i+1]) //如果一直找到nums[0]都没有升序数值对,说明整个序列已经是最大序列了(整体降序) 
		{
			//直接返回逆序后的升序序列
			reverse(nums.begin(),nums.end());
			return; 
		 } 
		 
		else if(nums[i]<nums[i+1]) //此时nums[i]就是较小数 
		{
			//找到了较小数后开始找较大数
			//在[i+1,n)中从右往左进行查找，找到第一个nums[j]>nums[i]，则nums[j]为较大数
			for(;j>=i+1;j--)
			{
				if(nums[j]>nums[i])
					break;
			}//此时nums[i]为较小数,nums[j]为较大数 
			
			//②将nums[i]和nums[j]进行交换,交换后[i+1,n)依然是降序
			int temp=nums[i];
			nums[i]=nums[j];
			nums[j]=temp;
			
			//③将[i+1,n)逆序,变成升序序列
			reverse(nums.begin()+i+1,nums.end());
			
			//此时的nums容器中的序列即为下一个排列 
			return; 
		}
	}
    }
};
```

## 知识点

### 1. 形参实参的传递

(1) 值传递

此时实参一般是变量：

```C++
void find(int x){}
y=find(z);
```

上面的例子中，z是实参，x是形参。**形参变实参不变**，如果要使得形参变实参同时发生变化，在x前面加上'&'（比如《算法笔记1》第28条，函数要return不止一个变量的话，就可以使用'&'添加变量）。

在值传递过程中，实参和形参位于内存中两个不同地址中，实参先自己复制一次拷贝，再把拷贝复制给形参。所以，在值传递过程中，形参的变化不会对实参有任何的影响。

（2）地址传递（引用传递）

此时实参一般是指针（如数组的数组名、字符串名等）：

```c++
void find(int &x){}
y=find(z);
```

上面的例子中，**形参变实参也变**。在函数调用的时候，实参传递给你的是指针地址，地址一样也就意味着实参和形参是一样的。

### 2.reverse()逆序函数的用法

reverse()常用于数组、字符串、容器等。

需要包含头文件**#include<algorithm>**。

reverse()没有返回值，其中包含两个参数，均为迭代器：

```c++
template <class BidirectionalIterator>
void reverse(BidirectionalIterator first,BidirectionalIterator last);
```

例如，交换vector容器中元素的顺序：

```C++
vector<int> v={5,4,3,2,1};
reverse(v.begin(),v.end());
```

string类字符串：

```C++
string str="www.mathor";
reverse(str.begin(),str.begin()+5);
```

