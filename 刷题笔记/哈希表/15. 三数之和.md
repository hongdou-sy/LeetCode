[toc]

# 15. 三数之和

## 一、题目

<img src="C:\Users\hongdou\AppData\Roaming\Typora\typora-user-images\image-20220227095018518.png" alt="image-20220227095018518" style="zoom:80%;" />

## 二、思路——排序+双指针

### 1. 思路

**总体思路**：

1. 首先对数组进行排序，排序后固定一个数 $nums[i]$，再使用左右指针指向 $nums[i]$ 后面的两端，数字分别为 $nums[L]$ 和 $nums[R]$；
2. 对于第一个加数 $nums[i]$，有两点要注意：
   * 如果 $nums[i]>0$，则三数之和不可能等于0，结束循环；
   * 去重：如果 $nums[i]==nums[i-1]$，说明数字重复，会导致结果重复，所以应该跳过。
3. 对于第二个加数 $nums[L]$ 和第三个加数 $nums[R]$：
   * 当 $sum<0$ 时，说明 $nums[L]$ 小了，使 $L++$;
   * 当 $sum>0$ 时，说明 $nums[R]$ 大了，使 $R--$；
   * 当 $sum==0$ 时，将该组数添加进结果集，去重后，使 $L$ 和 $R$ 指向下一个非重复值。

**思考过程**：

​	暴力法的时间复杂度是 $O(n^3)$，可以先固定一个值，然后寻找后两个值时可采取**双指针**的方法，将总的时间复杂度优化到 $O(n^2)$。

​	**暴力法**：如果我们直接使用三重循环枚举三元组，会得到 $O(n^3)$ 个满足题目要求的三元组（其中 $n$ 为数组的长度）。在这之后，我们还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。这个做法的时间复杂度和空间复杂度都很高，因此我们需要换一种思路。

「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：

* 第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；

* 第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。

也就是说，我们枚举的三元组 $(a,b,c)$ 满足 $a≤b≤c$ ，保证了只有 $(a,b,c)$ 这个顺序会被枚举到，而 $(b,a,c)$、$(c,b,a)$ 等等这些不会，这样就减少了重复。要实现这一点，我们可以将数组中的元素从小到大进行**排序**，随后使用普通的三重循环就可以满足上面的要求。

​	同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。举个例子，如果排完序的数组为

```c++
[0, 1, 2, 2, 2, 3]
 ^  ^  ^
```

​	我们使用三重循环枚举到的第一个三元组为 $(0,1,2)$ ，如果第三重循环继续枚举下一个元素，那么仍然是三元组 $(0,1,2)$ ，产生了重复。因此我们需要将第三重循环「跳到」下一个不相同的元素，即数组中的最后一个元素 3，枚举三元组 $(0,1,3)$ 。

> 注意：去重的思路不太一样。对于第一个加数 $nums[i]$，要保证两次枚举的元素均不相同；而对于第二个和第三个加数 $nums[L]$ 和 $nums[R]$，只有在 $sum==0$ 的时候才有必要执行去重，其他情况因为不会影响最终的结果集，因此不用考虑去重。

​	这种方法的时间复杂度仍然为 $O(n^3)$，毕竟我们还没有跳出三重循环的大框架。然而它是很容易优化的。可以发现，如果我们固定了前两重循环枚举到的元素 $a$ 和 $b$，那么只有唯一的 $c$ 满足 $a+b+c=0$。当二重循环往后枚举一个元素 $b'$ 时，由于 $b'>b$，那么要满足 $a+b'+c'=0$ 的 $c'$ 一定会满足 $c'<c$，即 $c'$ 在数组中一定会出现在 $c$ 的左侧。也就是说，我们可以**从小到大枚举** $b$，同时**从大到小枚举 $c$，**即**第二重循环和第三重循环实际上是并列的关系**。我们这里就是**将第三重循环变成一个从数组最右端开始向左移动的指针**。

​	这个方法就是我们常说的**「双指针」**，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 $O(n^2)$ 减少至 $O(n)$。 为什么是 $O(n)$ 呢？因为【左指针】每向右移动一步，【右指针】都会向左移动一步，一共会移动的步数为 $O(n)$，因此时间复杂度为 $O(n)$。

### 2. 代码

```C++
//时间打败93%,空间打败98% 
class Solution{
public:
	vector<vector<int> > threeSum(vector<int>& nums)
	{
		//先进行排序
		sort(nums.begin(),nums.end());
		vector<vector<int> > ans;
		
		int length=nums.size();
		if(length<3) return ans;
		for(int i=0;i<length;i++) //第一重循环 
		{
			if(nums[i]>0) break; //如果第一个数就>0,说明后面不可能再有两个数使得和为0了
			if(i>0 && nums[i]==nums[i-1]) continue; //一重循环去重 
			
			//使用双指针L和R,初始时分别指向nums[i]后的头元素和尾元素 
			int L=i+1;
			int R=length-1;
			while(L<R) //进入二重循环,确定第二个和第三个加数 
			{
				int sum=nums[i]+nums[L]+nums[R];
				if(sum>0) //如果此时三数之和>0,说明nums[R]大了 
					R--;
				else if(sum<0) //如果此时三数之和<0,说明nums[L]小了
					L++; 
				else if(sum==0)//如果此时三数之和等于0,存入结果后继续下一组遍历 
				{
					ans.push_back({nums[i],nums[L],nums[R]}); //存入结果 
					while(L<R && nums[L+1]==nums[L]) L++; //去重,保证下一个L和上一个不同 
					while(L<R && nums[R-1]==nums[R]) R--; //去重,保证下一个R和上一个不同 
					L++;
					R--; 
				} 
			}
		}
		return ans;
	}
};
```

### 3. 复杂度分析

* 时间复杂度：$O(n^2)$。排序的时间复杂度为 $O(nlogn)$，一共两重循环，时间复杂度为 $O(n^2)$。因此总体的时间复杂度为 $O(n^2)$。
* 空间复杂度：$O(logn)$。主要是快速排序过程中递归造成的栈空间的使用。

## 三、知识点

### I. vector的排序操作sort

#### 1. 基本用法

​	对vector执行升序排序：

```C++
sort(vi.begin(),vi.end())
```

​	对vector执行降序排序：

```C++
bool cmp(int x,int y)
{
	return x>y;
}
sort(vi.begin(),vi.end(),cmp)
```

#### 2. STL中sort使用的排序算法以及快排的复杂度分析

**【问题1】**sort排序使用的是什么算法？

【答】使用到了快速排序，但不仅仅只用了快速排序，还结合了插入排序和堆排序。

​	STL的sort算法，数据量大时采用**QuickSort快排算法**。一旦分段后的数据量小于某个门槛（16），为避免QuickSort快排的递归调用带来过大的额外负荷，就改用**Insertion Sort插入排序**。如果递归层次过深，还会改用**HeapSort堆排序**。

**【问题2】**快速排序最好和最坏时间复杂度是多少？如何计算的？

| 算法     | 平均时间   | 最好时间   | 最坏时间 | 空间      |
| -------- | ---------- | ---------- | -------- | --------- |
| 快速排序 | $O(nlogn)$ | $O(nlogn)$ | $O(n^2)$ | $O(logn)$ |

**最好情况**：

​	**每次所取的基准就是该数组的中点**，如果要排序 $n$ 个关键字，其递归树的深度就为 $log(2n+1)$，树的节点总数为 $n$ 。

​	第一次划分，需要对整个数组扫描一遍，做 $n$ 次比较：

```C++
T(n)=2T(n/2)+n
```

​	将数组一分为二，每个部分继续划分，扫描一遍需要做 $n/2$ 次比较：

```C++
T(n/2)=2T(n/4)+n/2
```

​	不断划分下去，计算过程如下：

<img src="C:\Users\hongdou\AppData\Local\Temp\Image.png" alt="Image" style="zoom:70%;" />



**最坏情况**：

​	所取的基准总是数组中最小的，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个子序列为空。如果画出递归树，它就是一棵斜树。

​	因此我们需要执行 $n-1$ 次划分。在第 $i$ 次划分时，区间长度为 $n-i+1$，需要进行 $n-i$ 次比较，因此比较次数共有：

<img src="C:\Users\hongdou\AppData\Roaming\Typora\typora-user-images\image-20220227111640158.png" alt="image-20220227111640158" style="zoom:80%;" />

​	因此，最坏情况下的时间复杂度为 $O(n^2)$。

**【问题3】**空间复杂度如何得到的？

**最好情况**：

​	空间复杂度主要是递归造成的栈空间的使用，在最好的情况下，递归树的深度为 $logn$ 。其空间复杂度也就为 $O(logn)$ 。

**最坏情况**：

​	需要进行 $n-1$ 递归调用，其空间复杂度为 $O(n)$ 。







